/*
 * Copyright (C) 2023 Synopsys Inc.
 * http://www.synopsys.com/
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Synopsys ("Confidential Information"). You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Synopsys.
 */
package com.synopsys.bd.kb.httpclient.impl;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import javax.annotation.Nullable;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.synopsys.bd.kb.httpclient.model.CvssScore;
import com.synopsys.bd.kb.httpclient.model.OverallScore;
import com.synopsys.bd.kb.httpclient.model.RelatedVulnerability;
import com.synopsys.bd.kb.httpclient.model.Vulnerability;
import com.synopsys.bd.kb.httpclient.model.VulnerabilityPriorityRanking;
import com.synopsys.kb.httpclient.model.BdsaVulnerability;
import com.synopsys.kb.httpclient.model.CveVulnerability;
import com.synopsys.kb.httpclient.model.Cvss2Score;
import com.synopsys.kb.httpclient.model.Cvss3Score;
import com.synopsys.kb.httpclient.model.SourcedVulnerability;
import com.synopsys.kb.httpclient.model.VulnerabilitySeverity;
import com.synopsys.kb.httpclient.model.VulnerabilitySource;
import com.synopsys.kb.httpclient.model.VulnerabilitySourcePriority;
import com.synopsys.kb.httpclient.model.VulnerabilityStatus;

/**
 * Black Duck-centric vulnerability merger.
 * 
 * Merges vulnerabilities from multiple sources.
 * 
 * @author skatzman
 */
public final class BdVulnerabilityMerger {
    public BdVulnerabilityMerger() {
    }

    /**
     * Merges vulnerabilities from multiple sources given a conventional rule set.
     * 
     * This operation will automatically...
     * - ...filter out vulnerabilities without any scoring (no CVSS2 score and no CVSS3 score)
     * - ...filter out vulnerabilities with 'NOT_AFFECTED' status.
     * - ...filter out duplicate vulnerabilities across vulnerability sources and give retention priority by the
     * provided source priority.
     * - ...define an overall score for each retained vulnerability by the provided score priority.
     * 
     * The merging process does NOT filter out vulnerabilities with 'PATCHED' status by default. It is possible that
     * 'PATCHED' vulnerabilities are filtered out in given vulnerability priority ranking filtering scenarios.
     * 
     * A vulnerability's overall score is determined by the provided source priority and score priority.
     * 
     * CVE vulnerability without a related BDSA vulnerability
     * - BDSA_CVSS3 - Fallback to next prioritized ranking.
     * - BDSA_CVSS2 - Fallback to next prioritized ranking.
     * - CVE_CVSS3 - Use CVSS3 score and fallback to next prioritized ranking otherwise.
     * - CVE_CVSS2 - Use CVSS2 score and fallback to next prioritized ranking otherwise.
     * 
     * BDSA vulnerability without a related CVE vulnerability
     * - BDSA_CVSS3 - Use CVSS3 score and fallback to next prioritized ranking otherwise.
     * - BDSA_CVSS2 - Use CVSS2 score and fallback to next prioritized ranking otherwise.
     * - CVE_CVSS3 - Fallback to next prioritized ranking.
     * - CVE_CVSS2 - Fallback to next prioritized ranking.
     * 
     * BDSA vulnerability with a related CVE vulnerability
     * A BDSA and CVE vulnerability are related if and only if the BDSA vulnerability has a 'cve' metadata relationship
     * to a CVE vulnerability id and that CVE vulnerability and both the BDSA and CVE vulnerabilities are associated to
     * the same component version or component variant.
     * - BDSA_CVSS3
     * -- If BDSA CVSS3 score is present, use it, and drop related CVE vulnerability.
     * -- Otherwise, fallback to next prioritized ranking.
     * - BDSA_CVSS2
     * -- If BDSA CVSS2 score is present, use it, and drop related CVE vulnerability.
     * -- Otherwise, fallback to next prioritized ranking.
     * - CVE_CVSS3
     * -- If CVE CVSS3 score is present, use it, and drop related BDSA vulnerability.
     * -- Otherwise, fallback to next prioritized ranking.
     * - CVE_CVSS2
     * -- If CVE CVSS2 score is present, use it, and drop related BDSA vulnerability.
     * -- Otherwise, fallback to next prioritized ranking.
     * 
     * @param cveVulnerabilities
     *            The CVE vulnerabilities.
     * @param bdsaVulnerabilities
     *            The BDSA vulnerabilities.
     * @param vulnerabilityPriorityRankings
     *            The vulnerability priority rankings.
     * @return Returns the vulnerabilities.
     */
    public List<Vulnerability> merge(List<CveVulnerability> cveVulnerabilities,
            List<BdsaVulnerability> bdsaVulnerabilities,
            List<VulnerabilityPriorityRanking> vulnerabilityPriorityRankings) {
        Objects.requireNonNull(cveVulnerabilities, "CVE vulnerabilities must be initialized.");
        Objects.requireNonNull(bdsaVulnerabilities, "BDSA vulnerabilities must be initialized.");
        Objects.requireNonNull(vulnerabilityPriorityRankings, "Vulnerability priority rankings must be initialized.");

        long numberOfDistinctVulnerabilityPriorityRankings = vulnerabilityPriorityRankings.stream().distinct().count();
        Preconditions.checkArgument(
                numberOfDistinctVulnerabilityPriorityRankings == Long.valueOf(VulnerabilityPriorityRanking.NUMBER_OF_VULNERABILITY_PRIORITY_RANKINGS)
                        .longValue(),
                "Expected all vulnerability priority rankings to be present within the provided parameter.");

        // First, filter out CVE and BDSA vulnerabilities that...
        // ...have no associated CVSS2 or CVSS3 score (unscored).
        // ...have NOT_AFFECTED vulnerability status.
        Map<String, CveVulnerability> filteredCveVulnerabilities = filterAndMap(cveVulnerabilities, false);
        Map<String, BdsaVulnerability> filteredBdsaVulnerabilities = filterAndMap(bdsaVulnerabilities, false);
        Set<String> relatedCveVulnerabilityIds = new HashSet<>();

        ImmutableList.Builder<Vulnerability> builder = ImmutableList.<Vulnerability> builder();

        // Next, iterate through each BDSA vulnerability to determine retentions, removals, and conversions.
        for (Entry<String, BdsaVulnerability> entry : filteredBdsaVulnerabilities.entrySet()) {
            String bdsaVulnerabilityId = entry.getKey();
            BdsaVulnerability bdsaVulnerability = entry.getValue();
            String relatedCveVulnerabilityId = bdsaVulnerability.getRelatedCveVulnerabilityId().orElse(null);

            RelatedVulnerability relatedVulnerability = null;
            if (relatedCveVulnerabilityId != null) {
                // A CVE vulnerability id is associated to this BDSA vulnerability.
                boolean isAssociated = filteredCveVulnerabilities.containsKey(relatedCveVulnerabilityId);
                relatedVulnerability = new RelatedVulnerability(VulnerabilitySource.NVD, relatedCveVulnerabilityId, isAssociated);
            }

            if (relatedVulnerability != null && relatedVulnerability.isAssociated()) {
                // BDSA vulnerability is related to a CVE vulnerability and the CVE vulnerability is also present.
                relatedCveVulnerabilityIds.add(relatedCveVulnerabilityId);

                CveVulnerability cveVulnerability = Objects.requireNonNull(filteredCveVulnerabilities.get(relatedCveVulnerabilityId),
                        "CVE vulnerability must be present.");

                // Determine whether to retain the CVE vulnerability or the BDSA vulnerability based on the
                // vulnerability priority rankings.
                VulnerabilitySource retainedVulnerabilitySource = determineRetainedVulnerability(cveVulnerability, bdsaVulnerability,
                        vulnerabilityPriorityRankings);

                // Determine the overall score for the retained vulnerability based on the vulnerability priority
                // rankings. Convert retained vulnerability to common vulnerability type.
                if (VulnerabilitySource.BDSA.equals(retainedVulnerabilitySource)) {
                    // Retain BDSA vulnerability.
                    OverallScore overallScore = determineOverallScore(bdsaVulnerability, vulnerabilityPriorityRankings);
                    Vulnerability vulnerability = new Vulnerability(bdsaVulnerability, overallScore, relatedVulnerability);
                    builder = builder.add(vulnerability);
                } else {
                    // Retain CVE vulnerability.
                    OverallScore overallScore = determineOverallScore(cveVulnerability, vulnerabilityPriorityRankings);
                    RelatedVulnerability bdsaRelatedVulnerability = new RelatedVulnerability(VulnerabilitySource.BDSA, bdsaVulnerabilityId, true);
                    Vulnerability vulnerability = new Vulnerability(cveVulnerability, overallScore, bdsaRelatedVulnerability);
                    builder = builder.add(vulnerability);
                }
            } else {
                // BDSA vulnerability is not related to a CVE vulnerability or...
                // ...BDSA vulnerability is related to a CVE vulnerability but the CVE vulnerability is absent.
                // Either way, convert the BDSA vulnerability to a common vulnerability type.
                OverallScore overallScore = determineOverallScore(bdsaVulnerability, vulnerabilityPriorityRankings);
                Vulnerability vulnerability = new Vulnerability(bdsaVulnerability, overallScore, relatedVulnerability);
                builder = builder.add(vulnerability);
            }
        }

        // Next, iterate through each CVE vulnerability.
        for (Entry<String, CveVulnerability> entry : filteredCveVulnerabilities.entrySet()) {
            String cveVulnerabilityId = entry.getKey();
            if (!relatedCveVulnerabilityIds.contains(cveVulnerabilityId)) {
                // CVE vulnerability is NOT associated to a BDSA vulnerability related CVE vulnerability.
                // Convert CVE vulnerability to common vulnerability type.
                CveVulnerability cveVulnerability = entry.getValue();
                OverallScore overallScore = determineOverallScore(cveVulnerability, vulnerabilityPriorityRankings);
                Vulnerability vulnerability = new Vulnerability(cveVulnerability, overallScore, null);
                builder = builder.add(vulnerability);
            } // CVE vulnerability is related which means it was already processed for retention or removal.
        }

        return builder.build();
    }

    /**
     * Determine which of the two CVE and BDSA vulnerabilities to retain given the vulnerabilities and the provided
     * vulnerability priority rankings.
     * 
     * @param cveVulnerability
     *            The CVE vulnerability.
     * @param bdsaVulnerability
     *            The BDSA vulnerability.
     * @param vulnerabilityPriorityRankings
     *            The vulnerability priority rankings.
     * @return VulnerabilitySource Returns the vulnerability source of the retained vulnerability.
     */
    public VulnerabilitySource determineRetainedVulnerability(CveVulnerability cveVulnerability,
            BdsaVulnerability bdsaVulnerability,
            List<VulnerabilityPriorityRanking> vulnerabilityPriorityRankings) {
        for (VulnerabilityPriorityRanking vulnerabilityPriorityRanking : vulnerabilityPriorityRankings) {
            if (VulnerabilityPriorityRanking.BDSA_CVSS3.equals(vulnerabilityPriorityRanking)) {
                // BDSA CVSS3 is prioritized.
                Cvss3Score cvss3Score = bdsaVulnerability.getCvss3Score().orElse(null);
                if (cvss3Score != null && cvss3Score.getBaseScore().isPresent()) {
                    // BDSA vulnerability has a CVSS3 score with assigned base score so retain this BDSA vulnerability.
                    return VulnerabilitySource.BDSA;
                }
            } else if (VulnerabilityPriorityRanking.CVE_CVSS3.equals(vulnerabilityPriorityRanking)) {
                // CVE CVSS3 is prioritized.
                Cvss3Score cvss3Score = cveVulnerability.getCvss3Score().orElse(null);
                if (cvss3Score != null && cvss3Score.getBaseScore().isPresent()) {
                    // CVE vulnerability has a CVSS3 score with assigned base score so retain this CVE vulnerability.
                    return VulnerabilitySource.NVD;
                }
            } else if (VulnerabilityPriorityRanking.BDSA_CVSS2.equals(vulnerabilityPriorityRanking)) {
                // BDSA CVSS2 is prioritized.
                Cvss2Score cvss2Score = bdsaVulnerability.getCvss2Score().orElse(null);
                if (cvss2Score != null && cvss2Score.getBaseScore().isPresent()) {
                    // BDSA vulnerability has a CVSS2 score with assigned base score so retain this BDSA vulnerability.
                    return VulnerabilitySource.BDSA;
                }
            } else if (VulnerabilityPriorityRanking.CVE_CVSS2.equals(vulnerabilityPriorityRanking)) {
                // CVE CVSS2 is prioritized.
                Cvss2Score cvss2Score = cveVulnerability.getCvss2Score().orElse(null);
                if (cvss2Score != null && cvss2Score.getBaseScore().isPresent()) {
                    // CVE vulnerability has a CVSS2 score with assigned base score so retain this CVE vulnerability.
                    return VulnerabilitySource.NVD;
                }
            }
        }

        // No vulnerability retention could be determined. This can occur if both vulnerabilities are unscored.
        // Retain the vulnerability in alignment to the highest vulnerability priority rank source.
        VulnerabilityPriorityRanking vulnerabilityPriorityRanking = vulnerabilityPriorityRankings.get(0);

        return VulnerabilitySourcePriority.BDSA.equals(vulnerabilityPriorityRanking.getSourcePriority()) ? VulnerabilitySource.BDSA : VulnerabilitySource.NVD;
    }

    /**
     * Determines overall score for only a CVE vulnerability.
     * 
     * @param cveVulnerability
     *            The CVE vulnerability.
     * @param vulnerabilityPriorityRankings
     *            The vulnerability priority rankings.
     * @return Returns the overall score.
     */
    @Nullable
    private OverallScore determineOverallScore(CveVulnerability cveVulnerability,
            List<VulnerabilityPriorityRanking> vulnerabilityPriorityRankings) {
        for (VulnerabilityPriorityRanking vulnerabilityPriorityRanking : vulnerabilityPriorityRankings) {
            if (VulnerabilityPriorityRanking.CVE_CVSS3.equals(vulnerabilityPriorityRanking)) {
                // CVE CVSS3 is prioritized.
                Cvss3Score cvss3Score = cveVulnerability.getCvss3Score().orElse(null);
                if (cvss3Score != null && cvss3Score.getBaseScore().isPresent()) {
                    // CVE vulnerability has a CVSS3 score with assigned base score.
                    double score = cvss3Score.getBaseScore().orElseThrow(() -> new IllegalStateException("Base score must be present.")).doubleValue();
                    VulnerabilitySeverity severity = cvss3Score.getSeverity().orElseThrow(() -> new IllegalStateException("Severity must be present."));

                    return new OverallScore(score, severity, CvssScore.CVSS3);
                } // Otherwise, CVSS3 scoring is absent and fallback is required so fallback to next ranking.
            } else if (VulnerabilityPriorityRanking.CVE_CVSS2.equals(vulnerabilityPriorityRanking)) {
                // CVE CVSS2 is prioritized.
                Cvss2Score cvss2Score = cveVulnerability.getCvss2Score().orElse(null);
                if (cvss2Score != null && cvss2Score.getBaseScore().isPresent()) {
                    double score = cvss2Score.getBaseScore().orElseThrow(() -> new IllegalStateException("Base score must be present.")).doubleValue();
                    VulnerabilitySeverity severity = cvss2Score.getSeverity().orElseThrow(() -> new IllegalStateException("Severity must be present."));

                    return new OverallScore(score, severity, CvssScore.CVSS2);
                }
            } // Otherwise, risk ranking is BDSA-specific and irrelevant.
        }

        // No overall score could be determined from this vulnerability.
        // Vulnerability may be unscored.
        return null;
    }

    /**
     * Determines overall score for only a BDSA vulnerability.
     * 
     * @param bdsaVulnerability
     *            The BDSA vulnerability.
     * @param vulnerabilityPriorityRankings
     *            The vulnerability priority rankings.
     * @return Returns the overall score.
     */
    @Nullable
    private OverallScore determineOverallScore(BdsaVulnerability bdsaVulnerability,
            List<VulnerabilityPriorityRanking> vulnerabilityPriorityRankings) {
        for (VulnerabilityPriorityRanking vulnerabilityPriorityRanking : vulnerabilityPriorityRankings) {
            if (VulnerabilityPriorityRanking.BDSA_CVSS3.equals(vulnerabilityPriorityRanking)) {
                // BDSA CVSS3 is prioritized.
                Cvss3Score cvss3Score = bdsaVulnerability.getCvss3Score().orElse(null);
                if (cvss3Score != null && cvss3Score.getBaseScore().isPresent()) {
                    // BDSA vulnerability has a CVSS3 score with assigned base score.
                    double score = cvss3Score.getBaseScore().orElseThrow(() -> new IllegalStateException("Base score must be present.")).doubleValue();
                    VulnerabilitySeverity severity = cvss3Score.getSeverity().orElseThrow(() -> new IllegalStateException("Severity must be present."));

                    return new OverallScore(score, severity, CvssScore.CVSS3);
                } // Otherwise, CVSS3 scoring is absent and fallback is required so fallback to next ranking.
            } else if (VulnerabilityPriorityRanking.BDSA_CVSS2.equals(vulnerabilityPriorityRanking)) {
                // BDSA CVSS2 is prioritized.
                Cvss2Score cvss2Score = bdsaVulnerability.getCvss2Score().orElse(null);
                if (cvss2Score != null && cvss2Score.getBaseScore().isPresent()) {
                    double score = cvss2Score.getBaseScore().orElseThrow(() -> new IllegalStateException("Base score must be present.")).doubleValue();
                    VulnerabilitySeverity severity = cvss2Score.getSeverity().orElseThrow(() -> new IllegalStateException("Severity must be present."));

                    return new OverallScore(score, severity, CvssScore.CVSS2);
                }
            } // Otherwise, risk ranking is NVD-specific and irrelevant.
        }

        // No overall score could be determined from this vulnerability.
        // Vulnerability may be unscored.
        return null;
    }

    /**
     * Filters the given sourced vulnerabilities for unscored vulnerabilities and not affected vulnerabilities.
     * 
     * @param <T>
     *            The sourced vulnerability type.
     * @param sourcedVulnerabilities
     *            The sourced vulnerabilities.
     * @param isUnscoredVulnerabilityRetained
     *            The retention flag for unscored vulnerabilities.
     * @return Returns the filtered vulnerabilities in the form of a map (vulnerability id to sourced vulnerability).
     */
    private <T extends SourcedVulnerability> Map<String, T> filterAndMap(List<T> sourcedVulnerabilities,
            boolean isUnscoredVulnerabilityRetained) {
        return sourcedVulnerabilities.stream().filter((sourcedVulnerability) -> {
            boolean isScoringValid = true;
            if (!isUnscoredVulnerabilityRetained) {
                // Only scored vulnerabilities should be retained.
                // Unscored vulnerabilities are explicitly removed by filtering.

                // Determine if vulnerability has CandVSS2 score metadata and a defined CVSS2 base score.
                boolean isCvss2ScorePresent = sourcedVulnerability.getCvss2Score().map((cvss2Score) -> cvss2Score.getBaseScore().orElse(null)).isPresent();

                // Determine if vulnerability has CVSS3 score metadata and a defined CVSS3 base score.
                boolean isCvss3ScorePresent = sourcedVulnerability.getCvss3Score().map((cvss3Score) -> cvss3Score.getBaseScore().orElse(null)).isPresent();

                isScoringValid = (isCvss2ScorePresent || isCvss3ScorePresent);
            }

            // Determine if vulnerability is affected.
            boolean isAffected = sourcedVulnerability.getStatus().filter((vulnerabilityStatus) -> !VulnerabilityStatus.NOT_AFFECTED.equals(vulnerabilityStatus))
                    .isPresent();

            return (isScoringValid && isAffected);
        }).collect(Collectors.toMap((sourcedVulnerability) -> {
            return sourcedVulnerability.getId();
        }, Function.identity(), (left, right) -> left));
    }
}
