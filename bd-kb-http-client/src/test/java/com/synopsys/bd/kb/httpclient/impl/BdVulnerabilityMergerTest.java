/*
 * Copyright (C) 2023 Synopsys Inc.
 * http://www.synopsys.com/
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Synopsys ("Confidential Information"). You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Synopsys.
 */
package com.synopsys.bd.kb.httpclient.impl;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.testng.Assert;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import com.google.common.collect.ImmutableList;
import com.synopsys.bd.kb.httpclient.AbstractBdTest;
import com.synopsys.bd.kb.httpclient.model.CvssScore;
import com.synopsys.bd.kb.httpclient.model.OverallScore;
import com.synopsys.bd.kb.httpclient.model.RelatedVulnerability;
import com.synopsys.bd.kb.httpclient.model.Vulnerability;
import com.synopsys.bd.kb.httpclient.model.VulnerabilityPriorityRanking;
import com.synopsys.kb.httpclient.model.BdsaVulnerability;
import com.synopsys.kb.httpclient.model.CveVulnerability;
import com.synopsys.kb.httpclient.model.Cvss2Score;
import com.synopsys.kb.httpclient.model.Cvss3Score;
import com.synopsys.kb.httpclient.model.SourcedVulnerability;
import com.synopsys.kb.httpclient.model.VulnerabilityScorePriority;
import com.synopsys.kb.httpclient.model.VulnerabilitySeverity;
import com.synopsys.kb.httpclient.model.VulnerabilitySource;
import com.synopsys.kb.httpclient.model.VulnerabilitySourcePriority;
import com.synopsys.kb.httpclient.model.VulnerabilityStatus;

/**
 * Black Duck-centric vulnerability merger test.
 * 
 * @author skatzman
 */
public class BdVulnerabilityMergerTest extends AbstractBdTest {
    // Test a subset of the 24 vulnerability priority ranking permutations but give testing focus to the most common
    // permutations out of the complete set.
    private static final List<VulnerabilityPriorityRanking> BDSA_CVSS3_RANKINGS = ImmutableList.<VulnerabilityPriorityRanking> builder()
            .add(VulnerabilityPriorityRanking.BDSA_CVSS3)
            .add(VulnerabilityPriorityRanking.CVE_CVSS3)
            .add(VulnerabilityPriorityRanking.BDSA_CVSS2)
            .add(VulnerabilityPriorityRanking.CVE_CVSS2).build();

    private static final List<VulnerabilityPriorityRanking> CVE_CVSS3_RANKINGS = ImmutableList.<VulnerabilityPriorityRanking> builder()
            .add(VulnerabilityPriorityRanking.CVE_CVSS3)
            .add(VulnerabilityPriorityRanking.BDSA_CVSS3)
            .add(VulnerabilityPriorityRanking.CVE_CVSS2)
            .add(VulnerabilityPriorityRanking.BDSA_CVSS2).build();

    private static final List<VulnerabilityPriorityRanking> BDSA_RANKINGS = ImmutableList.<VulnerabilityPriorityRanking> builder()
            .add(VulnerabilityPriorityRanking.BDSA_CVSS3)
            .add(VulnerabilityPriorityRanking.BDSA_CVSS2)
            .add(VulnerabilityPriorityRanking.CVE_CVSS3)
            .add(VulnerabilityPriorityRanking.CVE_CVSS2).build();

    private static final List<VulnerabilityPriorityRanking> CVE_RANKINGS = ImmutableList.<VulnerabilityPriorityRanking> builder()
            .add(VulnerabilityPriorityRanking.CVE_CVSS3)
            .add(VulnerabilityPriorityRanking.CVE_CVSS2)
            .add(VulnerabilityPriorityRanking.BDSA_CVSS3)
            .add(VulnerabilityPriorityRanking.BDSA_CVSS2).build();

    private BdVulnerabilityMerger bdVulnerabilityMerger;

    @BeforeMethod
    public void beforeMethod() {
        bdVulnerabilityMerger = new BdVulnerabilityMerger();
    }

    @Test
    public void testMergeWithNoVulnerabilitiesAndBdsaCvss3Rankings() {
        List<CveVulnerability> cveVulnerabilities = Collections.emptyList();
        List<BdsaVulnerability> bdsaVulnerabilities = Collections.emptyList();

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, BDSA_CVSS3_RANKINGS);

        Assert.assertTrue(vulnerabilities.isEmpty(), "Vulnerabilities should be empty.");
    }

    @Test
    public void testMergeWithNoVulnerabilitiesAndCveCvss3Rankings() {
        List<CveVulnerability> cveVulnerabilities = Collections.emptyList();
        List<BdsaVulnerability> bdsaVulnerabilities = Collections.emptyList();

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, CVE_CVSS3_RANKINGS);

        Assert.assertTrue(vulnerabilities.isEmpty(), "Vulnerabilities should be empty.");
    }

    @Test
    public void testMergeWithNoVulnerabilitiesAndBdsaRankings() {
        List<CveVulnerability> cveVulnerabilities = Collections.emptyList();
        List<BdsaVulnerability> bdsaVulnerabilities = Collections.emptyList();

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, BDSA_RANKINGS);

        Assert.assertTrue(vulnerabilities.isEmpty(), "Vulnerabilities should be empty.");
    }

    @Test
    public void testMergeWithNoVulnerabilitiesAndCveRankings() {
        List<CveVulnerability> cveVulnerabilities = Collections.emptyList();
        List<BdsaVulnerability> bdsaVulnerabilities = Collections.emptyList();

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, CVE_RANKINGS);

        Assert.assertTrue(vulnerabilities.isEmpty(), "Vulnerabilities should be empty.");
    }

    @Test
    public void testMergeWithAbsentBdsaVulnerabilitiesAndBdsaCvss3Rankings() {
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, false, false);
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, false, true);
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, true, false);
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);
        List<BdsaVulnerability> bdsaVulnerabilities = Collections.emptyList();

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, BDSA_CVSS3_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = ImmutableList
                .<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(cveVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(cveVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(cveVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = Collections.emptyList();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithAbsentBdsaVulnerabilitiesAndCveCvss3Rankings() {
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, false, false);
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, false, true);
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, true, false);
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);
        List<BdsaVulnerability> bdsaVulnerabilities = Collections.emptyList();

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, CVE_CVSS3_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = ImmutableList
                .<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(cveVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(cveVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(cveVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = Collections.emptyList();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithAbsentBdsaVulnerabilitiesAndBdsaRankings() {
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, false, false);
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, false, true);
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, true, false);
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);
        List<BdsaVulnerability> bdsaVulnerabilities = Collections.emptyList();

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, BDSA_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = ImmutableList
                .<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(cveVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(cveVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(cveVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = Collections.emptyList();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithAbsentBdsaVulnerabilitiesAndCveRankings() {
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, false, false);
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, false, true);
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, true, false);
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);
        List<BdsaVulnerability> bdsaVulnerabilities = Collections.emptyList();

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, CVE_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = ImmutableList
                .<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(cveVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(cveVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(cveVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = Collections.emptyList();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithAbsentCveVulnerabilitiesAndBdsaCvss3Rankings() {
        List<CveVulnerability> cveVulnerabilities = Collections.emptyList();
        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, false, false, null);
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, null);
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, null);
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, null);
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);
        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, BDSA_CVSS3_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = Collections.emptyList();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(bdsaVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(bdsaVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithAbsentCveVulnerabilitiesAndCveCvss3Rankings() {
        List<CveVulnerability> cveVulnerabilities = Collections.emptyList();
        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, false, false, null);
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, null);
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, null);
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, null);
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);
        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, CVE_CVSS3_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = Collections.emptyList();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(bdsaVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(bdsaVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithAbsentCveVulnerabilitiesAndBdsaRankings() {
        List<CveVulnerability> cveVulnerabilities = Collections.emptyList();
        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, false, false, null);
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, null);
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, null);
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, null);
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);
        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, BDSA_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = Collections.emptyList();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(bdsaVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(bdsaVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithAbsentCveVulnerabilitiesAndCveRankings() {
        List<CveVulnerability> cveVulnerabilities = Collections.emptyList();
        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, false, false, null);
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, null);
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, null);
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, null);
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);
        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, CVE_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = Collections.emptyList();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(bdsaVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(bdsaVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithNoRelatedVulnerabilitiesAndBdsaCvss3Rankings() {
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, false, false);
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, false, true);
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, true, false);
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);

        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, false, false, null);
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, null);
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, null);
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, null);
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, BDSA_CVSS3_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = ImmutableList
                .<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(cveVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(cveVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(cveVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(bdsaVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(bdsaVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithNoRelatedVulnerabilitiesAndCveCvss3Rankings() {
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, false, false);
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, false, true);
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, true, false);
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);

        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, false, false, null);
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, null);
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, null);
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, null);
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, CVE_CVSS3_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = ImmutableList
                .<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(cveVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(cveVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(cveVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(bdsaVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(bdsaVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithNoRelatedVulnerabilitiesAndBdsaRankings() {
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, false, false);
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, false, true);
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, true, false);
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);

        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, false, false, null);
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, null);
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, null);
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, null);
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, BDSA_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = ImmutableList
                .<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(cveVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(cveVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(cveVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(bdsaVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(bdsaVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithNoRelatedVulnerabilitiesAndCveRankings() {
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, false, false);
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, false, true);
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, true, false);
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);

        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, false, false, null);
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, null);
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, null);
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, null);
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, CVE_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = ImmutableList
                .<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(cveVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(cveVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(cveVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability2, CvssScore.CVSS3, Optional.empty()))
                .add(Triple.of(bdsaVulnerability3, CvssScore.CVSS2, Optional.empty()))
                .add(Triple.of(bdsaVulnerability4, CvssScore.CVSS3, Optional.empty())).build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithRelatedVulnerabilitiesAndBdsaCvss3Rankings1() {
        // BDSA3 > CVE3 > BDSA2 > CVE2

        // Removed (unscored).
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, false, false);
        // Removed (lower priority).
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, false, true);
        // Removed (lower priority).
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, true, false);
        // Removed (lower priority).
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);

        // Removed (unscored).
        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, false, false, "CVE-2023-0001");
        // Retained (higher priority).
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, "CVE-2023-0002");
        // Retained (higher priority).
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, "CVE-2023-0003");
        // Retained (higher priority).
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, "CVE-2023-0004");
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, BDSA_CVSS3_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = Collections.emptyList();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability2, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0002", true))))
                .add(Triple.of(bdsaVulnerability3, CvssScore.CVSS2, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0003", true))))
                .add(Triple.of(bdsaVulnerability4, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0004", true))))
                .build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithRelatedVulnerabilitiesAndBdsaCvss3Rankings2() {
        // BDSA3 > CVE3 > BDSA2 > CVE2

        // Removed (lower priority).
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, true, true);
        // Removed (lower priority).
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, true, false);
        // Retained (higher priority).
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, false, true);
        // Removed (lower priority).
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);

        // Retained (higher priority).
        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, true, true, "CVE-2023-0001");
        // Retained (higher priority).
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, "CVE-2023-0002");
        // Removed (lower priority).
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, "CVE-2023-0003");
        // Retained (higher priority).
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, "CVE-2023-0004");
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, BDSA_CVSS3_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = ImmutableList
                .<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(cveVulnerability3, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.BDSA, "BDSA-2023-0003", true))))
                .build();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability1, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0001", true))))
                .add(Triple.of(bdsaVulnerability2, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0002", true))))
                .add(Triple.of(bdsaVulnerability4, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0004", true))))
                .build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithRelatedVulnerabilitiesAndCveCvss3Rankings1() {
        // CVE3 > BDSA3 > CVE2 > BDSA2

        // Removed (unscored).
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, false, false);
        // Retained (higher priority).
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, false, true);
        // Retained (higher priority).
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, true, false);
        // Retained (higher priority).
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);

        // Removed (unscored).
        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, false, false, "CVE-2023-0001");
        // Removed (lower priority).
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, "CVE-2023-0002");
        // Removed (lower priority).
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, "CVE-2023-0003");
        // Removed (lower priority).
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, "CVE-2023-0004");
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, CVE_CVSS3_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = ImmutableList
                .<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(cveVulnerability2, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.BDSA, "BDSA-2023-0002", true))))
                .add(Triple.of(cveVulnerability3, CvssScore.CVSS2, Optional.of(new RelatedVulnerability(VulnerabilitySource.BDSA, "BDSA-2023-0003", true))))
                .add(Triple.of(cveVulnerability4, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.BDSA, "BDSA-2023-0004", true))))
                .build();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = Collections.emptyList();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithRelatedVulnerabilitiesAndCveCvss3Rankings2() {
        // CVE3 > BDSA3 > CVE2 > BDSA2

        // Retained (higher priority).
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, true, true);
        // Removed (lower priority).
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, true, false);
        // Retained (higher priority).
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, false, true);
        // Retained (higher priority).
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);

        // Removed (lower priority).
        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, true, true, "CVE-2023-0001");
        // Retained (higher priority).
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, "CVE-2023-0002");
        // Removed (lower priority).
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, "CVE-2023-0003");
        // Removed (lower priority).
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, "CVE-2023-0004");
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, CVE_CVSS3_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = ImmutableList
                .<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(cveVulnerability1, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.BDSA, "BDSA-2023-0001", true))))
                .add(Triple.of(cveVulnerability3, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.BDSA, "BDSA-2023-0003", true))))
                .add(Triple.of(cveVulnerability4, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.BDSA, "BDSA-2023-0004", true))))
                .build();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability2, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0002", true))))
                .build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithRelatedVulnerabilitiesAndBdsaRankings1() {
        // BDSA3 > BDSA2 > CVE3 > CVE2

        // Removed (unscored).
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, false, false);
        // Removed (lower priority).
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, false, true);
        // Removed (lower priority).
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, true, false);
        // Removed (lower priority).
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);

        // Removed (unscored).
        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, false, false, "CVE-2023-0001");
        // Retained (higher priority).
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, "CVE-2023-0002");
        // Retained (higher priority).
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, "CVE-2023-0003");
        // Retained (higher priority).
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, "CVE-2023-0004");
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, BDSA_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = Collections.emptyList();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability2, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0002", true))))
                .add(Triple.of(bdsaVulnerability3, CvssScore.CVSS2, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0003", true))))
                .add(Triple.of(bdsaVulnerability4, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0004", true))))
                .build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithRelatedVulnerabilitiesAndBdsaRankings2() {
        // BDSA3 > BDSA2 > CVE3 > CVE2

        // Removed (lower priority).
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, true, true);
        // Removed (lower priority).
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, true, false);
        // Removed (lower priority).
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, false, true);
        // Removed (lower priority).
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);

        // Retained (higher priority).
        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, true, true, "CVE-2023-0001");
        // Retained (higher priority)
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, "CVE-2023-0002");
        // Retained (higher priority)
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, "CVE-2023-0003");
        // Retained (higher priority).
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, "CVE-2023-0004");
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, BDSA_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = Collections.emptyList();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability1, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0001", true))))
                .add(Triple.of(bdsaVulnerability2, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0002", true))))
                .add(Triple.of(bdsaVulnerability3, CvssScore.CVSS2, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0003", true))))
                .add(Triple.of(bdsaVulnerability4, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0004", true))))
                .build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithRelatedVulnerabilitiesAndCveRankings1() {
        // CVE3 > CVE2 > BDSA3 > BDSA2

        // Removed (unscored).
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, false, false);
        // Retained (higher priority - CVE3 > BDSA3).
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, false, true);
        // Retained (higher priority - CVE2 > BDSA2).
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, true, false);
        // Retained (higher priority).
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, true, true);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);

        // Removed (unscored).
        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, false, false, "CVE-2023-0001");
        // Removed (lower priority - BDSA3 < CVE3).
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, "CVE-2023-0002");
        // Removed (lower priority - BDSA2 < CVE 2).
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, "CVE-2023-0003");
        // Removed (lower priority - BDSA3 < CVE2 < CVE3, BDSA2 < CVE2 < CVE3).
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, "CVE-2023-0004");
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, CVE_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = ImmutableList
                .<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(cveVulnerability2, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.BDSA, "BDSA-2023-0002", true))))
                .add(Triple.of(cveVulnerability3, CvssScore.CVSS2, Optional.of(new RelatedVulnerability(VulnerabilitySource.BDSA, "BDSA-2023-0003", true))))
                .add(Triple.of(cveVulnerability4, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.BDSA, "BDSA-2023-0004", true))))
                .build();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = Collections.emptyList();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @Test
    public void testMergeWithRelatedVulnerabilitiesAndCveRankings2() {
        // CVE3 > CVE2 > BDSA3 > BDSA2

        // Retained (higher priority - CVE3 > CVE2 > BDSA3)
        CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, true, true);
        // Retained (higher priority - CVE2 > BDSA3).
        CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0002", VulnerabilityStatus.AFFECTED, true, false);
        // Retained (higher priority - CVE3 > BDSA2).
        CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0003", VulnerabilityStatus.AFFECTED, false, true);
        // Removed (unscored)
        CveVulnerability cveVulnerability4 = constructCveVulnerability("CVE-2023-0004", VulnerabilityStatus.AFFECTED, false, false);
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability1, cveVulnerability2, cveVulnerability3, cveVulnerability4);

        // Removed (lower priority - BDSA3 < CVE2 < CVE3)
        BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, true, true, "CVE-2023-0001");
        // Removed (lower priority - BDSA3 < CVE2).
        BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0002", VulnerabilityStatus.AFFECTED, false, true, "CVE-2023-0002");
        // Removed (lower priority - BDSA2 < CVE3).
        BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0003", VulnerabilityStatus.AFFECTED, true, false, "CVE-2023-0003");
        // Retained (related is unscored).
        BdsaVulnerability bdsaVulnerability4 = constructBdsaVulnerability("BDSA-2023-0004", VulnerabilityStatus.AFFECTED, true, true, "CVE-2023-0004");
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability1, bdsaVulnerability2, bdsaVulnerability3, bdsaVulnerability4);

        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, CVE_RANKINGS);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = ImmutableList
                .<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(cveVulnerability1, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.BDSA, "BDSA-2023-0001", true))))
                .add(Triple.of(cveVulnerability2, CvssScore.CVSS2, Optional.of(new RelatedVulnerability(VulnerabilitySource.BDSA, "BDSA-2023-0002", true))))
                .add(Triple.of(cveVulnerability3, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.BDSA, "BDSA-2023-0003", true))))
                .build();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = ImmutableList
                .<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> builder()
                .add(Triple.of(bdsaVulnerability4, CvssScore.CVSS3, Optional.of(new RelatedVulnerability(VulnerabilitySource.NVD, "CVE-2023-0004", false))))
                .build();
        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    @DataProvider(name = "relatedDataProvider")
    public Object[][] createRelatedDataProvider() {
        VulnerabilityPriorityRanking[] rankings = VulnerabilityPriorityRanking.values();
        List<VulnerabilityPriorityRanking> rankingsList = Arrays.asList(rankings);
        int numberOfRankings = rankingsList.size();
        List<List<VulnerabilityPriorityRanking>> permutations = new ArrayList<List<VulnerabilityPriorityRanking>>();
        permute(rankingsList, numberOfRankings, numberOfRankings, permutations);

        List<Object[]> objects = new ArrayList<>();
        for (List<VulnerabilityPriorityRanking> permutation : permutations) {
            CveVulnerability cveVulnerability1 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, true, true);
            CveVulnerability cveVulnerability2 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, true, false);
            CveVulnerability cveVulnerability3 = constructCveVulnerability("CVE-2023-0001", VulnerabilityStatus.AFFECTED, false, true);
            BdsaVulnerability bdsaVulnerability1 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, true, true, "CVE-2023-0001");
            BdsaVulnerability bdsaVulnerability2 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, true, false, "CVE-2023-0001");
            BdsaVulnerability bdsaVulnerability3 = constructBdsaVulnerability("BDSA-2023-0001", VulnerabilityStatus.AFFECTED, false, true, "CVE-2023-0001");

            // true, true -> true, true
            Object[] object1 = new Object[] { cveVulnerability1, bdsaVulnerability1, permutation };
            objects.add(object1);

            // true, true -> true, false
            Object[] object2 = new Object[] { cveVulnerability1, bdsaVulnerability2, permutation };
            objects.add(object2);

            // true, true -> false, true
            Object[] object3 = new Object[] { cveVulnerability1, bdsaVulnerability3, permutation };
            objects.add(object3);

            // true, false -> true, true
            Object[] object4 = new Object[] { cveVulnerability2, bdsaVulnerability1, permutation };
            objects.add(object4);

            // true, false -> true, false
            Object[] object5 = new Object[] { cveVulnerability2, bdsaVulnerability2, permutation };
            objects.add(object5);

            // true, false -> false, true
            Object[] object6 = new Object[] { cveVulnerability2, bdsaVulnerability3, permutation };
            objects.add(object6);

            // false, true -> true, true
            Object[] object7 = new Object[] { cveVulnerability3, bdsaVulnerability1, permutation };
            objects.add(object7);

            // false, true -> true, false
            Object[] object8 = new Object[] { cveVulnerability3, bdsaVulnerability2, permutation };
            objects.add(object8);

            // false, true -> false, true
            Object[] object9 = new Object[] { cveVulnerability3, bdsaVulnerability3, permutation };
            objects.add(object9);
        }

        return objects.toArray(new Object[][] {});
    }

    @Test(dataProvider = "relatedDataProvider")
    public void testMergeWithRelated(CveVulnerability cveVulnerability,
            BdsaVulnerability bdsaVulnerability,
            List<VulnerabilityPriorityRanking> rankings) {
        /*
         * Tests merging related vulnerabilities for all ranking permutations and all affected, scored vulnerability
         * permutations.
         * 
         * This currently tests a product of 24 unique vulnerability priority ranking permutations in combination with 9
         * scored vulnerability permutations (24 * 9 = 216 tests).
         */
        List<CveVulnerability> cveVulnerabilities = List.of(cveVulnerability);
        List<BdsaVulnerability> bdsaVulnerabilities = List.of(bdsaVulnerability);
        List<Vulnerability> vulnerabilities = bdVulnerabilityMerger.merge(cveVulnerabilities, bdsaVulnerabilities, rankings);

        List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples = new ArrayList<>();
        List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples = new ArrayList<>();
        Triple<Boolean, CvssScore, RelatedVulnerability> triple = evaluate(cveVulnerability, bdsaVulnerability, rankings);
        Assert.assertNotNull(triple, "Triple must be initialized.");
        boolean isCveVulnerabilityRetained = triple.getLeft().booleanValue();
        CvssScore cvssScore = triple.getMiddle();
        RelatedVulnerability relatedVulnerability = triple.getRight();
        if (isCveVulnerabilityRetained) {
            expectedCveTriples.add(Triple.of(cveVulnerability, cvssScore, Optional.of(relatedVulnerability)));
        } else {
            expectedBdsaTriples.add(Triple.of(bdsaVulnerability, cvssScore, Optional.of(relatedVulnerability)));
        }

        assertVulnerabilities(vulnerabilities, expectedCveTriples, expectedBdsaTriples);
    }

    private void assertVulnerabilities(List<Vulnerability> actualVulnerabilities,
            List<Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedCveTriples,
            List<Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>>> expectedBdsaTriples) {
        int numberOfExpectedCveVulnerabilities = expectedCveTriples.size();
        int numberOfExpectedBdsaVulnerabilities = expectedBdsaTriples.size();
        int numberOfExpectedVulnerabilities = numberOfExpectedCveVulnerabilities + numberOfExpectedBdsaVulnerabilities;
        Assert.assertEquals(actualVulnerabilities.size(), numberOfExpectedVulnerabilities, "Number of vulnerabilities should be equal.");

        Map<String, Vulnerability> actualVulnerabilityMap = actualVulnerabilities.stream()
                .collect(Collectors.toMap(Vulnerability::getId, Function.identity(), (left, right) -> left));

        for (Triple<CveVulnerability, CvssScore, Optional<RelatedVulnerability>> expectedCveTriple : expectedCveTriples) {
            CveVulnerability expectedCveVulnerability = expectedCveTriple.getLeft();
            String cveVulnerabilityId = expectedCveVulnerability.getId();
            Assert.assertTrue(actualVulnerabilityMap.containsKey(cveVulnerabilityId), "CVE vulnerability should be present.");

            CvssScore expectedCveCvssScore = expectedCveTriple.getMiddle();
            OverallScore expectedCveOverallScore = convert(expectedCveVulnerability, expectedCveCvssScore);
            Vulnerability actualCveVulnerability = actualVulnerabilityMap.get(cveVulnerabilityId);
            OverallScore actualCveOverallScore = actualCveVulnerability.getOverallScore().orElse(null);
            Assert.assertNotNull(actualCveOverallScore, "CVE overall score should be initialized.");
            Assert.assertEquals(actualCveOverallScore, expectedCveOverallScore, "Overall scores should be equal.");

            RelatedVulnerability actualCveRelatedVulnerability = actualCveVulnerability.getRelatedVulnerability().orElse(null);
            expectedCveTriple.getRight().ifPresentOrElse((expectedCveRelatedVulnerability) -> {
                Assert.assertNotNull(actualCveRelatedVulnerability, "Related vulnerability should be initialized.");
                Assert.assertEquals(actualCveRelatedVulnerability, expectedCveRelatedVulnerability, "CVE related vulnerabilities should be equal.");
            }, () -> {
                Assert.assertNull(actualCveRelatedVulnerability, "Related vulnerability should be null.");
            });
        }

        for (Triple<BdsaVulnerability, CvssScore, Optional<RelatedVulnerability>> expectedBdsaTriple : expectedBdsaTriples) {
            BdsaVulnerability expectedBdsaVulnerability = expectedBdsaTriple.getLeft();
            String bdsaVulnerabilityId = expectedBdsaVulnerability.getId();
            Assert.assertTrue(actualVulnerabilityMap.containsKey(bdsaVulnerabilityId), "BDSA vulnerability should be present.");

            CvssScore expectedBdsaCvssScore = expectedBdsaTriple.getMiddle();
            OverallScore expectedBdsaOverallScore = convert(expectedBdsaVulnerability, expectedBdsaCvssScore);
            Vulnerability actualBdsaVulnerability = actualVulnerabilityMap.get(bdsaVulnerabilityId);
            OverallScore actualBdsaOverallScore = actualBdsaVulnerability.getOverallScore().orElse(null);
            Assert.assertNotNull(actualBdsaOverallScore, "BDSA overall score should be initialized.");
            Assert.assertEquals(actualBdsaOverallScore, expectedBdsaOverallScore, "Overall scores should be equal.");

            RelatedVulnerability actualBdsaRelatedVulnerability = actualBdsaVulnerability.getRelatedVulnerability().orElse(null);
            expectedBdsaTriple.getRight().ifPresentOrElse((expectedBdsaRelatedVulnerability) -> {
                Assert.assertNotNull(actualBdsaRelatedVulnerability, "Related vulnerability should be initialized.");
                Assert.assertEquals(actualBdsaRelatedVulnerability, expectedBdsaRelatedVulnerability, "BDSA related vulnerabilities should be equal.");
            }, () -> {
                Assert.assertNull(actualBdsaRelatedVulnerability, "Related vulnerability should be null.");
            });
        }
    }

    private OverallScore convert(SourcedVulnerability sourcedVulnerability, CvssScore cvssScore) {
        if (CvssScore.CVSS3.equals(cvssScore)) {
            // CVSS3
            Cvss3Score cvss3Score = sourcedVulnerability.getCvss3Score().orElseThrow(() -> new IllegalArgumentException("CVSS3 score must be present."));
            double score = cvss3Score.getBaseScore().orElseThrow(() -> new IllegalArgumentException("CVSS3 base score must be present.")).doubleValue();
            VulnerabilitySeverity severity = cvss3Score.getSeverity().orElseThrow(() -> new IllegalArgumentException("CVSS3 severity must be present."));

            return new OverallScore(score, severity, cvssScore);
        }

        // CVSS2
        Cvss2Score cvss2Score = sourcedVulnerability.getCvss2Score().orElseThrow(() -> new IllegalArgumentException("CVSS2 score must be present."));
        double score = cvss2Score.getBaseScore().orElseThrow(() -> new IllegalArgumentException("CVSS2 base score must be present.")).doubleValue();
        VulnerabilitySeverity severity = cvss2Score.getSeverity().orElseThrow(() -> new IllegalArgumentException("CVSS2 severity must be present."));

        return new OverallScore(score, severity, cvssScore);
    }

    /**
     * Find all permutations for the vulnerability priority rankings.
     * 
     * @param rankings
     *            The rankings.
     * @param n
     *            The size of the rankings list.
     * @param k
     *            The required number of rankings in each permutation.
     * @param results
     *            The results.
     */
    private void permute(List<VulnerabilityPriorityRanking> rankings,
            int n,
            int k,
            List<List<VulnerabilityPriorityRanking>> results) {
        if (0 == k) {
            List<VulnerabilityPriorityRanking> singlePermutation = new ArrayList<>();
            for (int i = n; i < rankings.size(); i++) {
                singlePermutation.add(rankings.get(i));
            }
            results.add(singlePermutation);

            return;
        }

        for (int i = 0; i < n; i++) {
            swap(rankings, i, n - 1);
            permute(rankings, n - 1, k - 1, results);
            swap(rankings, i, n - 1);
        }
    }

    private void swap(List<VulnerabilityPriorityRanking> rankings, int i, int j) {
        VulnerabilityPriorityRanking temp = rankings.get(i);
        rankings.set(i, rankings.get(j));
        rankings.set(j, temp);
    }

    private Triple<Boolean, CvssScore, RelatedVulnerability> evaluate(CveVulnerability cveVulnerability,
            BdsaVulnerability bdsaVulnerability,
            List<VulnerabilityPriorityRanking> rankings) {
        for (VulnerabilityPriorityRanking ranking : rankings) {
            VulnerabilitySourcePriority sourcePriority = ranking.getSourcePriority();
            VulnerabilityScorePriority scorePriority = ranking.getScorePriority();
            if (VulnerabilitySourcePriority.BDSA.equals(sourcePriority)) {
                // BDSA
                if (VulnerabilityScorePriority.CVSS_3.equals(scorePriority)) {
                    // CVSS3
                    if (bdsaVulnerability.getCvss3Score().isPresent()) {
                        String relatedCveVulnerabilityId = cveVulnerability.getId();
                        RelatedVulnerability relatedVulnerability = new RelatedVulnerability(VulnerabilitySource.NVD, relatedCveVulnerabilityId, true);

                        return Triple.of(Boolean.FALSE, CvssScore.CVSS3, relatedVulnerability);
                    } // Otherwise, fallback.
                } else {
                    // CVSS2
                    if (bdsaVulnerability.getCvss2Score().isPresent()) {
                        String relatedCveVulnerabilityId = cveVulnerability.getId();
                        RelatedVulnerability relatedVulnerability = new RelatedVulnerability(VulnerabilitySource.NVD, relatedCveVulnerabilityId, true);

                        return Triple.of(Boolean.FALSE, CvssScore.CVSS2, relatedVulnerability);
                    }
                }
            } else {
                // NVD
                if (VulnerabilityScorePriority.CVSS_3.equals(scorePriority)) {
                    // CVSS3
                    if (cveVulnerability.getCvss3Score().isPresent()) {
                        String relatedBdsaVulnerabilityId = bdsaVulnerability.getId();
                        RelatedVulnerability relatedVulnerability = new RelatedVulnerability(VulnerabilitySource.BDSA, relatedBdsaVulnerabilityId, true);

                        return Triple.of(Boolean.TRUE, CvssScore.CVSS3, relatedVulnerability);
                    }
                } else {
                    // CVSS2
                    if (cveVulnerability.getCvss2Score().isPresent()) {
                        String relatedBdsaVulnerabilityId = bdsaVulnerability.getId();
                        RelatedVulnerability relatedVulnerability = new RelatedVulnerability(VulnerabilitySource.BDSA, relatedBdsaVulnerabilityId, true);

                        return Triple.of(Boolean.TRUE, CvssScore.CVSS2, relatedVulnerability);
                    }
                }
            }
        }

        return null;
    }

    private static final class Triple<L, M, R> {
        private final L left;

        private final M middle;

        private final R right;

        private Triple(L left, M middle, R right) {
            this.left = Objects.requireNonNull(left, "Left must be initialized.");
            this.middle = Objects.requireNonNull(middle, "Middle must be initialized.");
            this.right = Objects.requireNonNull(right, "Right must be initialized.");
        }

        public static <L, M, R> Triple<L, M, R> of(L left, M middle, R right) {
            return new Triple<>(left, middle, right);
        }

        public L getLeft() {
            return left;
        }

        public M getMiddle() {
            return middle;
        }

        public R getRight() {
            return right;
        }
    }
}
