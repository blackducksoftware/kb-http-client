/*
 * Copyright (C) 2023 Synopsys Inc.
 * http://www.synopsys.com/
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Synopsys ("Confidential Information"). You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Synopsys.
 */
package com.synopsys.kb.httpclient.model;

import java.time.OffsetDateTime;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import org.testng.Assert;
import org.testng.annotations.Test;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.synopsys.kb.httpclient.AbstractTest;
import com.synopsys.kb.httpclient.api.Relationship;

/**
 * BDSA vulnerability test.
 * 
 * @author skatzman
 */
public class BdsaVulnerabilityTest extends AbstractTest {
    private static final String ID = "BDSA-2023-0001";

    private static final String TITLE = "This is a title.";

    private static final String DESCRIPTION = "This is a description.";

    private static final String TECHNICAL_DESCRIPTION = "This is a technical description.";

    private static final String WORKAROUND = "This is a workaround.";

    private static final String SOLUTION = "This is a solution.";

    private static final String CREDIT = "This is a credit.";

    private static final OffsetDateTime PUBLISHED_DATE = OffsetDateTime.now();

    private static final OffsetDateTime LAST_MODIFIED_DATE = OffsetDateTime.now();

    private static final OffsetDateTime DISCOVERY_DATE = OffsetDateTime.now();

    private static final OffsetDateTime VENDOR_NOTIFIED_DATE = OffsetDateTime.now();

    private static final OffsetDateTime DISCLOSURE_DATE = OffsetDateTime.now();

    private static final OffsetDateTime VENDOR_FIX_DATE = OffsetDateTime.now();

    private static final OffsetDateTime EXPLOIT_AVAILABLE_DATE = OffsetDateTime.now();

    private static final Boolean ZERO_DAY = Boolean.TRUE;

    private static final Boolean UNDER_REVIEW = Boolean.TRUE;

    private static final Boolean PARENT_ADVISORY = Boolean.FALSE;

    private static final Cvss2Score CVSS2_SCORE = new Cvss2Score(1.0d, 2.0d, 3.0d, VulnerabilitySeverity.LOW, Cvss2AccessVector.ADJACENT_NETWORK,
            Cvss2AccessComplexity.HIGH, Cvss2Authentication.MULTIPLE_INSTANCES, Cvss2ConfidentialityImpact.COMPLETE, Cvss2IntegrityImpact.COMPLETE,
            Cvss2AvailabilityImpact.COMPLETE, VulnerabilitySource.BDSA, "This is a CVSS2 vector.",
            new Cvss2TemporalMetrics(4.0d, Cvss2Exploitability.FUNCTIONAL, Cvss2RemediationLevel.NOT_DEFINED, Cvss2ReportConfidence.CONFIRMED));

    private static final Cvss3Score CVSS3_SCORE = new Cvss3Score(1.0d, 2.0d, 3.0d, VulnerabilitySeverity.CRITICAL, Cvss3AttackVector.ADJACENT,
            Cvss3AttackComplexity.HIGH, Cvss3ConfidentialityImpact.HIGH, Cvss3IntegrityImpact.HIGH, Cvss3AvailabilityImpact.HIGH, Cvss3PrivilegesRequired.HIGH,
            Cvss3Scope.CHANGED, Cvss3UserInteraction.NONE, VulnerabilitySource.BDSA, "This is a CVSS3 vector.",
            new Cvss3TemporalMetrics(4.0d, Cvss3ExploitCodeMaturity.FUNCTIONAL, Cvss3RemediationLevel.NOT_DEFINED, Cvss3ReportConfidence.CONFIRMED));

    private static final List<VulnerabilityReference> REFERENCES = List.of(new VulnerabilityReference("source", "https://www.blah.com", "content", "type"));

    private static final VulnerabilityStatus STATUS = VulnerabilityStatus.AFFECTED;

    private static final Collection<String> TAGS = Set.of("1", "2", "3");

    private static final Meta META = new Meta("https://kbtest.blackducksoftware.com/api/vulnerabilities/bdsa/" + ID, Collections.emptyList());

    @Test
    public void testConstructor() {
        BdsaVulnerability bdsaVulnerability = new BdsaVulnerability(TITLE, DESCRIPTION, TECHNICAL_DESCRIPTION, WORKAROUND, SOLUTION, CREDIT, PUBLISHED_DATE,
                LAST_MODIFIED_DATE, DISCOVERY_DATE, VENDOR_NOTIFIED_DATE, DISCLOSURE_DATE, VENDOR_FIX_DATE, EXPLOIT_AVAILABLE_DATE, ZERO_DAY, UNDER_REVIEW,
                PARENT_ADVISORY, CVSS2_SCORE, CVSS3_SCORE, REFERENCES, STATUS, TAGS, META);

        Assert.assertEquals(bdsaVulnerability.getTitle(), TITLE, "Titles should be equal.");
        Assert.assertEquals(bdsaVulnerability.getDescription(), DESCRIPTION, "Description should be equal.");
        Assert.assertEquals(bdsaVulnerability.getTechnicalDescription().orElse(null), TECHNICAL_DESCRIPTION, "Technical description should be equal.");
        Assert.assertEquals(bdsaVulnerability.getWorkaround().orElse(null), WORKAROUND, "Workarounds should be equal.");
        Assert.assertEquals(bdsaVulnerability.getSolution().orElse(null), SOLUTION, "Solutions should be equal.");
        Assert.assertEquals(bdsaVulnerability.getCredit().orElse(null), CREDIT, "Credits should be equal.");
        Assert.assertEquals(bdsaVulnerability.getPublishedDate(), PUBLISHED_DATE, "Published dates should be equal.");
        Assert.assertEquals(bdsaVulnerability.getLastModifiedDate(), LAST_MODIFIED_DATE, "Last modified dates should be equal.");
        Assert.assertEquals(bdsaVulnerability.getDiscoveryDate().orElse(null), DISCOVERY_DATE, "Discovery dates should be equal.");
        Assert.assertEquals(bdsaVulnerability.getVendorNotifiedDate().orElse(null), VENDOR_NOTIFIED_DATE, "Vendor notified dates should be equal.");
        Assert.assertEquals(bdsaVulnerability.getDisclosureDate().orElse(null), DISCLOSURE_DATE, "Disclosure dates should be equal.");
        Assert.assertEquals(bdsaVulnerability.getVendorFixDate().orElse(null), VENDOR_FIX_DATE, "Vendor fix dates should be equal.");
        Assert.assertEquals(bdsaVulnerability.getExploitAvailableDate().orElse(null), EXPLOIT_AVAILABLE_DATE, "Exploit available dates should be equal.");
        Assert.assertTrue(bdsaVulnerability.isZeroDay(), "Vulnerability should be a zero day.");
        Assert.assertTrue(bdsaVulnerability.isUnderReview(), "Vulnerability should be under review.");
        Assert.assertFalse(bdsaVulnerability.isParentAdvisory(), "Vulnerability should not have a parent advisory.");
        Assert.assertEquals(bdsaVulnerability.getCvss2Score().orElse(null), CVSS2_SCORE, "CVSS2 scores should be equal.");
        Assert.assertEquals(bdsaVulnerability.getCvss3Score().orElse(null), CVSS3_SCORE, "CVSS3 scores should be equal.");
        Assert.assertEquals(bdsaVulnerability.getReferences(), REFERENCES, "References should be equal.");
        Assert.assertEquals(bdsaVulnerability.getStatus().orElse(null), STATUS, "Status should be equal.");
        Assert.assertEquals(bdsaVulnerability.getTags(), TAGS, "Tags should be equal.");
        Assert.assertEquals(bdsaVulnerability.getMeta(), META, "Metas should be equal.");

        Assert.assertEquals(bdsaVulnerability.getId(), ID, "Ids should be equal.");
    }

    @Test
    public void testIsWorkaroundPresentWhenAbsent() {
        BdsaVulnerability bdsaVulnerability = new BdsaVulnerability(TITLE, DESCRIPTION, TECHNICAL_DESCRIPTION, null, SOLUTION, CREDIT, PUBLISHED_DATE,
                LAST_MODIFIED_DATE, DISCOVERY_DATE, VENDOR_NOTIFIED_DATE, DISCLOSURE_DATE, VENDOR_FIX_DATE, EXPLOIT_AVAILABLE_DATE, ZERO_DAY, UNDER_REVIEW,
                PARENT_ADVISORY, CVSS2_SCORE, CVSS3_SCORE, REFERENCES, STATUS, TAGS, META);

        Assert.assertFalse(bdsaVulnerability.isWorkaroundPresent(), "Workaround should not be present.");
    }

    @Test
    public void testIsWorkaroundPresentWhenPresent() {
        BdsaVulnerability bdsaVulnerability = new BdsaVulnerability(TITLE, DESCRIPTION, TECHNICAL_DESCRIPTION, WORKAROUND, SOLUTION, CREDIT, PUBLISHED_DATE,
                LAST_MODIFIED_DATE, DISCOVERY_DATE, VENDOR_NOTIFIED_DATE, DISCLOSURE_DATE, VENDOR_FIX_DATE, EXPLOIT_AVAILABLE_DATE, ZERO_DAY, UNDER_REVIEW,
                PARENT_ADVISORY, CVSS2_SCORE, CVSS3_SCORE, REFERENCES, STATUS, TAGS, META);

        Assert.assertTrue(bdsaVulnerability.isWorkaroundPresent(), "Workaround should be present.");
    }

    @Test
    public void testIsSolutionPresentWhenAbsent() {
        BdsaVulnerability bdsaVulnerability = new BdsaVulnerability(TITLE, DESCRIPTION, TECHNICAL_DESCRIPTION, WORKAROUND, null, CREDIT, PUBLISHED_DATE,
                LAST_MODIFIED_DATE, DISCOVERY_DATE, VENDOR_NOTIFIED_DATE, DISCLOSURE_DATE, VENDOR_FIX_DATE, EXPLOIT_AVAILABLE_DATE, ZERO_DAY, UNDER_REVIEW,
                PARENT_ADVISORY, CVSS2_SCORE, CVSS3_SCORE, REFERENCES, STATUS, TAGS, META);

        Assert.assertFalse(bdsaVulnerability.isSolutionPresent(), "Solution should not be present.");
    }

    @Test
    public void testIsSolutionPresentWhenPresent() {
        BdsaVulnerability bdsaVulnerability = new BdsaVulnerability(TITLE, DESCRIPTION, TECHNICAL_DESCRIPTION, WORKAROUND, SOLUTION, CREDIT, PUBLISHED_DATE,
                LAST_MODIFIED_DATE, DISCOVERY_DATE, VENDOR_NOTIFIED_DATE, DISCLOSURE_DATE, VENDOR_FIX_DATE, EXPLOIT_AVAILABLE_DATE, ZERO_DAY, UNDER_REVIEW,
                PARENT_ADVISORY, CVSS2_SCORE, CVSS3_SCORE, REFERENCES, STATUS, TAGS, META);

        Assert.assertTrue(bdsaVulnerability.isSolutionPresent(), "Solution should be present.");
    }

    @Test
    public void testGetCweIdsWhenAbsent() {
        Meta meta = new Meta("https://kbtest.blackducksoftware.com/api/vulnerabilities/bdsa/" + ID, Collections.emptyList());

        BdsaVulnerability bdsaVulnerability = new BdsaVulnerability(TITLE, DESCRIPTION, TECHNICAL_DESCRIPTION, WORKAROUND, SOLUTION, CREDIT, PUBLISHED_DATE,
                LAST_MODIFIED_DATE, DISCOVERY_DATE, VENDOR_NOTIFIED_DATE, DISCLOSURE_DATE, VENDOR_FIX_DATE, EXPLOIT_AVAILABLE_DATE, ZERO_DAY, UNDER_REVIEW,
                PARENT_ADVISORY, CVSS2_SCORE, CVSS3_SCORE, REFERENCES, STATUS, TAGS, meta);

        Assert.assertTrue(bdsaVulnerability.getCweIds().isEmpty(), "CWE ids should be empty.");
    }

    @Test
    public void testGetCweIdsWhenPresent() {
        String cweId1 = "CWE-01";
        String cweId2 = "CWE-02";
        String cweId3 = "CWE-03";
        Meta meta = new Meta("https://kbtest.blackducksoftware.com/api/vulnerabilities/bdsa/" + ID,
                List.of(new Link(Relationship.CWE, "https://kbtest.blackducksoftware.com/api/cwe/" + cweId1),
                        new Link(Relationship.CWE, "https://kbtest.blackducksoftware.com/api/cwe/" + cweId2),
                        new Link(Relationship.CWE, "https://kbtest.blackducksoftware.com/api/cwe/" + cweId3)));

        BdsaVulnerability bdsaVulnerability = new BdsaVulnerability(TITLE, DESCRIPTION, TECHNICAL_DESCRIPTION, WORKAROUND, SOLUTION, CREDIT, PUBLISHED_DATE,
                LAST_MODIFIED_DATE, DISCOVERY_DATE, VENDOR_NOTIFIED_DATE, DISCLOSURE_DATE, VENDOR_FIX_DATE, EXPLOIT_AVAILABLE_DATE, ZERO_DAY, UNDER_REVIEW,
                PARENT_ADVISORY, CVSS2_SCORE, CVSS3_SCORE, REFERENCES, STATUS, TAGS, meta);

        Set<String> actualCweIds = bdsaVulnerability.getCweIds();
        Assert.assertFalse(actualCweIds.isEmpty(), "CWE ids should not be empty.");
        Set<String> expectedCweIds = Set.of(cweId1, cweId2, cweId3);
        Assert.assertEquals(actualCweIds.size(), expectedCweIds.size(), "Number of CWE ids should be equal.");
        Assert.assertTrue(actualCweIds.contains(cweId1), "CWE id should be present.");
        Assert.assertTrue(actualCweIds.contains(cweId2), "CWE id should be present.");
        Assert.assertTrue(actualCweIds.contains(cweId3), "CWE id should be present.");
    }

    @Test
    public void testGetRelatedCveVulnerabilityIdWhenAbsent() {
        BdsaVulnerability bdsaVulnerability = new BdsaVulnerability(TITLE, DESCRIPTION, TECHNICAL_DESCRIPTION, WORKAROUND, SOLUTION, CREDIT, PUBLISHED_DATE,
                LAST_MODIFIED_DATE, DISCOVERY_DATE, VENDOR_NOTIFIED_DATE, DISCLOSURE_DATE, VENDOR_FIX_DATE, EXPLOIT_AVAILABLE_DATE, ZERO_DAY, UNDER_REVIEW,
                PARENT_ADVISORY, CVSS2_SCORE, CVSS3_SCORE, REFERENCES, STATUS, TAGS, META);

        Optional<String> optionalRelatedCveVulnerabilityId = bdsaVulnerability.getRelatedCveVulnerabilityId();

        Assert.assertFalse(optionalRelatedCveVulnerabilityId.isPresent(), "Related CVE vulnerability id should not be present.");
    }

    @Test
    public void testGetRelatedCveVulnerabilityIdWhenPresent() {
        String cveVulnerabilityId = "CVE-2023-4423";
        Meta meta = new Meta("https://kbtest.blackducksoftware.com/api/vulnerabilities/bdsa/" + ID,
                List.of(new Link(Relationship.CVE, "https://kbtest.blackducksoftware.com/api/vulnerabilities/cve/" + cveVulnerabilityId)));

        BdsaVulnerability bdsaVulnerability = new BdsaVulnerability(TITLE, DESCRIPTION, TECHNICAL_DESCRIPTION, WORKAROUND, SOLUTION, CREDIT, PUBLISHED_DATE,
                LAST_MODIFIED_DATE, DISCOVERY_DATE, VENDOR_NOTIFIED_DATE, DISCLOSURE_DATE, VENDOR_FIX_DATE, EXPLOIT_AVAILABLE_DATE, ZERO_DAY, UNDER_REVIEW,
                PARENT_ADVISORY, CVSS2_SCORE, CVSS3_SCORE, REFERENCES, STATUS, TAGS, meta);

        Optional<String> optionalRelatedCveVulnerabilityId = bdsaVulnerability.getRelatedCveVulnerabilityId();

        Assert.assertTrue(optionalRelatedCveVulnerabilityId.isPresent(), "Related CVE vulnerability id should be present.");
        Assert.assertEquals(optionalRelatedCveVulnerabilityId.orElse(null), cveVulnerabilityId, "Related CVE vulnerability ids should be equal.");
    }

    @Test
    public void testDeserialization() throws JsonProcessingException {
        BdsaVulnerability bdsaVulnerability = new BdsaVulnerability(TITLE, DESCRIPTION, TECHNICAL_DESCRIPTION, WORKAROUND, SOLUTION, CREDIT, PUBLISHED_DATE,
                LAST_MODIFIED_DATE, DISCOVERY_DATE, VENDOR_NOTIFIED_DATE, DISCLOSURE_DATE, VENDOR_FIX_DATE, EXPLOIT_AVAILABLE_DATE, ZERO_DAY, UNDER_REVIEW,
                PARENT_ADVISORY, CVSS2_SCORE, CVSS3_SCORE, REFERENCES, STATUS, TAGS, META);

        String json = serialize(bdsaVulnerability);
        BdsaVulnerability result = deserialize(json, BdsaVulnerability.class);

        Assert.assertEquals(result.getTitle(), TITLE, "Titles should be equal.");
        Assert.assertEquals(result.getDescription(), DESCRIPTION, "Description should be equal.");
        Assert.assertEquals(result.getTechnicalDescription().orElse(null), TECHNICAL_DESCRIPTION, "Technical description should be equal.");
        Assert.assertEquals(result.getWorkaround().orElse(null), WORKAROUND, "Workarounds should be equal.");
        Assert.assertEquals(result.getSolution().orElse(null), SOLUTION, "Solutions should be equal.");
        Assert.assertEquals(result.getCredit().orElse(null), CREDIT, "Credits should be equal.");
        Assert.assertNotNull(result.getPublishedDate(), "Published dates should be initialized.");
        Assert.assertNotNull(result.getLastModifiedDate(), "Last modified dates should be initialized.");
        Assert.assertNotNull(result.getDiscoveryDate().orElse(null), "Discovery dates should be initialized.");
        Assert.assertNotNull(result.getVendorNotifiedDate().orElse(null), "Vendor notified dates should be initialized.");
        Assert.assertNotNull(result.getDisclosureDate().orElse(null), "Disclosure dates should be initialized.");
        Assert.assertNotNull(result.getVendorFixDate().orElse(null), "Vendor fix dates should be initialized.");
        Assert.assertNotNull(result.getExploitAvailableDate().orElse(null), "Exploit available dates should be initialized.");
        Assert.assertTrue(result.isZeroDay(), "Vulnerability should be a zero day.");
        Assert.assertTrue(result.isUnderReview(), "Vulnerability should be under review.");
        Assert.assertFalse(result.isParentAdvisory(), "Vulnerability should not have a parent advisory.");
        Assert.assertEquals(result.getCvss2Score().orElse(null), CVSS2_SCORE, "CVSS2 scores should be equal.");
        Assert.assertEquals(result.getCvss3Score().orElse(null), CVSS3_SCORE, "CVSS3 scores should be equal.");
        Assert.assertEquals(result.getReferences(), REFERENCES, "References should be equal.");
        Assert.assertEquals(result.getStatus().orElse(null), STATUS, "Status should be equal.");
        Assert.assertEquals(result.getTags(), TAGS, "Tags should be equal.");
        Assert.assertEquals(result.getMeta(), META, "Metas should be equal.");
    }
}
